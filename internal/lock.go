package internal

import (
	"bufio"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"log"
	"os"
	"slices"
	"strconv"
	"strings"
)

const lockFile = "jaxon.lock"

func createLockFile() error {
	file, err := os.Create(lockFile)
	if err != nil {
		return err
	}
	defer file.Close()

	_, err = file.WriteString("# this file was generated by jaxon")
	return err
}

func doesLockFileExist() bool {
	_, err := os.Stat(lockFile)
	return err == nil
}

func GetHashes() map[int64]string {
	if !doesLockFileExist() {
		if err := createLockFile(); err != nil {
			log.Fatal(err)
		}
	}

	file, err := os.Open(lockFile)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	hashes := make(map[int64]string)
	scanner := bufio.NewScanner(file)

	// decode file
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		// Skip comments and empty lines
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		parts := strings.SplitN(line, "=", 2)
		if len(parts) != 2 {
			log.Fatalf("invalid lock file line: %q", line)
		}

		id, err := strconv.ParseInt(strings.TrimSpace(parts[0]), 10, 64)
		if err != nil {
			log.Fatalf("invalid asset id in lock file: %q", parts[0])
		}

		hash := strings.TrimSpace(parts[1])
		if hash == "" {
			log.Fatalf("empty hash for asset id %d", id)
		}

		hashes[id] = hash
	}

	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}

	return hashes
}

func GetProductHash(product *ProductJson) string {
	input := Product{
		Name:            product.Name,
		Description:     product.Description,
		ImageFile:       product.Image,
		Price:           product.Price,
		RegionalPricing: product.RegionalPricing,
	}

	data, err := json.Marshal(input)
	if err != nil {
		log.Fatal(err)
	}

	sum := sha256.Sum256(data)
	return hex.EncodeToString(sum[:])
}

func WriteHashesToLockfile(hashes map[int64]string) {
	// Open file for read/write
	file, err := os.OpenFile(lockFile, os.O_RDWR, 0644)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	// Read existing lines
	scanner := bufio.NewScanner(file)
	var lines []string
	for scanner.Scan() {
		lines = append(lines, scanner.Text())
	}
	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}

	if len(lines) == 0 {
		log.Fatal("lock file is empty or malformed")
	}

	// Keep first line (comment)
	newLines := []string{lines[0]}

	// Sort keys for deterministic order
	keys := make([]int64, 0, len(hashes))
	for k := range hashes {
		keys = append(keys, k)
	}
	// sort ascending
	slices.Sort(keys)

	// Add hash entries
	for _, k := range keys {
		newLines = append(newLines, strconv.FormatInt(k, 10)+"="+hashes[k])
	}

	// Truncate file and write new content
	if err := file.Truncate(0); err != nil {
		log.Fatal(err)
	}
	if _, err := file.Seek(0, 0); err != nil {
		log.Fatal(err)
	}

	writer := bufio.NewWriter(file)
	for _, line := range newLines {
		if _, err := writer.WriteString(line + "\n"); err != nil {
			log.Fatal(err)
		}
	}
	if err := writer.Flush(); err != nil {
		log.Fatal(err)
	}
}
