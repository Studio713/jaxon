use anyhow::{Context, Result};
use sha2::{Digest, Sha256};
use std::collections::HashMap;
use std::io::{BufRead, Write};

use crate::products::ProductJson;
use crate::roblox::Product;

pub const LOCK_FILE: &str = "jaxon.lock";

fn lock_file_exists() -> bool {
    std::path::Path::new(LOCK_FILE).exists()
}

fn create_lock_file() -> Result<()> {
    std::fs::write(LOCK_FILE, "# this file was generated by jaxon\n")
        .context("Failed to create jaxon.lock")?;
    Ok(())
}

pub fn get_hashes() -> Result<HashMap<i64, String>> {
    if !lock_file_exists() {
        create_lock_file()?;
    }

    let file = std::fs::File::open(LOCK_FILE).context("Failed to open jaxon.lock")?;
    let reader = std::io::BufReader::new(file);

    let mut hashes = HashMap::new();
    for line in reader.lines() {
        let line = line.context("Failed to read jaxon.lock")?;
        let line = line.trim();

        if line.is_empty() || line.starts_with('#') {
            continue;
        }

        let parts: Vec<&str> = line.splitn(2, '=').collect();
        if parts.len() != 2 {
            anyhow::bail!("Invalid lock file line: {:?}", line)
        }

        let id: i64 = parts[0]
            .trim()
            .parse()
            .with_context(|| format!("Invalid product id in lock file: {:?}", parts[0]))?;

        let hash = parts[1].trim().to_string();
        if hash.is_empty() {
            anyhow::bail!("Empty hash for product id {}", id)
        }

        hashes.insert(id, hash);
    }

    Ok(hashes)
}

pub fn get_product_hash(product: &ProductJson) -> Result<String> {
    let input = Product {
        name: product.name.clone(),
        description: product.description.clone(),
        image_file: product.image.clone(),
        price: product.price,
        regional_pricing: product.regional_pricing,
    };
    let data = serde_json::to_vec(&input).context("Failed to serialize product for hashing")?;
    let hash = Sha256::digest(&data);
    Ok(hex::encode(hash))
}

pub fn write_hashes_to_lockfile(hashes: &HashMap<i64, String>) -> Result<()> {
    let file = std::fs::File::open(LOCK_FILE).context("Failed to create jaxon.lock")?;
    let reader = std::io::BufReader::new(file);
    let lines: Vec<String> = reader
        .lines()
        .collect::<std::io::Result<_>>()
        .context("Failed to read jaxon.lock")?;

    if lines.is_empty() {
        anyhow::bail!("Lock file is empty or malformed");
    }

    let mut keys: Vec<i64> = hashes.keys().copied().collect();
    keys.sort();

    let mut file =
        std::fs::File::create(LOCK_FILE).context("Failed to open jaxon.lock for writing")?;

    writeln!(file, "{}", lines[0]).context("Failed to write to jaxon.lock")?;

    for key in keys {
        writeln!(file, "{}={}", key, hashes[&key]).context("Failed to write to jaxon.lock")?;
    }

    file.flush().context("Failed to flush jaxon.lock")?;

    Ok(())
}
