use anyhow::{Context, Result};
use std::collections::HashMap;
use std::path::Path;

use crate::config::{Files, Generation};

#[derive(Clone)]
pub struct ProductCodeMap {
    pub name: String,
    pub id: i64,
    pub image: String,
}

fn generate_luau(
    products: &HashMap<i64, ProductCodeMap>,
    passes: &HashMap<i64, ProductCodeMap>,
) -> String {
    let mut out = String::new();

    out.push_str("-- Autogenerated by jaxon CLI\n");
    out.push_str("local Products = {\n");
    out.push_str("\tProducts = {\n");

    for product in products.values() {
        out.push_str(&format!(
            "\t\t[\"{}\"] = {{\n\t\t\tName = \"{}\",\n\t\t\tId = {},\n\t\t\tImage = \"{}\"\n\t\t}},\n",
            product.name, product.name, product.id, product.image
        ));
    }

    out.push_str("\t},\n");
    out.push_str("\tGamepasses = {\n");

    for pass in passes.values() {
        out.push_str(&format!(
            "\t\t[\"{}\"] = {{\n\t\t\tName = \"{}\",\n\t\t\tId = {},\n\t\t\tImage = \"{}\"\n\t\t}},\n",
            pass.name, pass.name, pass.id, pass.image
        ));
    }

    out.push_str("\t},\n");
    out.push_str("\tProductsById = {},\n");
    out.push_str("\tGamepassesById = {},\n");
    out.push_str("},\n");
    out.push_str("\nfor _,product in Products.Products do\n\t\tProducts.ProductsById[product.Id] = product\nend\n");
    out.push_str("\nfor _,gamepass in Products.Gamepasses do\n\t\tGamepasses.GamepassesById[gamepass.Id] = gamepass\nend\n");
    out.push_str("\nreturn Products");

    out
}

fn generate_typescript(
    products: &HashMap<i64, ProductCodeMap>,
    passes: &HashMap<i64, ProductCodeMap>,
) -> String {
    let mut out = String::new();

    out.push_str("// Autogenerated by jaxon CLI\n\n");

    let write_group = |out: &mut String, name: &str, items: &HashMap<i64, ProductCodeMap>| {
        out.push_str(&format!("\t{}: {{\n", name));
        for item in items.values() {
            out.push_str(&format!(
                "\t\t\"{}\": {{\n\t\t\tName: \"{}\";\n\t\t\tId: {};\n\t\t\tImage: \"{}\";\n\t\t}};\n",
                item.name, item.name, item.id, item.image
            ));
        }
        out.push_str("\t};\n");
    };

    out.push_str("declare const products: {\n");

    write_group(&mut out, "Products", products);
    write_group(&mut out, "Gamepasses", passes);

    out.push_str("\tProductsById: {\n");
    for item in products.values() {
        out.push_str(&format!(
            "\t\t{}: {{\n\t\t\tName: \"{}\";\n\t\t\tId: {};\n\t\t\tImage: \"{}\";\n\t\t}};\n",
            item.id, item.name, item.id, item.image
        ));
    }
    out.push_str("\t};\n");

    out.push_str("\tGamepassesById: {\n");
    for item in passes.values() {
        out.push_str(&format!(
            "\t\t{}: {{\n\t\t\tName: \"{}\";\n\t\t\tId: {};\n\t\t\tImage: \"{}\";\n\t\t}};\n",
            item.id, item.name, item.id, item.image
        ));
    }
    out.push_str("\t};\n");

    out.push_str("};\n\nexport = products;\n");

    out
}

pub fn generate_code(
    products: &HashMap<i64, ProductCodeMap>,
    passes: &HashMap<i64, ProductCodeMap>,
    generation: &Generation,
    files: &Files,
) -> Result<()> {
    let output_path = Path::new(&files.output);

    // Create parent directories if they don't exist
    if let Some(parent) = output_path.parent() {
        if !parent.as_os_str().is_empty() {
            std::fs::create_dir_all(parent).with_context(|| {
                format!("Failed to create directories for {}", output_path.display())
            })?;
        }
    }

    let luau_code = generate_luau(products, passes);
    std::fs::write(output_path, luau_code)
        .with_context(|| format!("Failed to write {}", output_path.display()))?;

    if generation.typescript {
        // Derive the .d.ts path by swapping the extension
        let ts_path = output_path.with_extension("d.ts");
        let ts_code = generate_typescript(products, passes);
        std::fs::write(&ts_path, ts_code)
            .with_context(|| format!("Failed to write {}", ts_path.display()))?;
    }

    Ok(())
}
